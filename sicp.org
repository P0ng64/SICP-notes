#+title: SICP notes
#+author: Zhipeng Bao
#+date: 2021-12-29

* Chapter 1. 构造过程抽象
我们将使用 Lisp 家族中的方言 Scheme。

书上是这么说的，但是由于万恶的 Apple Silicon 不支持 mit-scheme，我们只能曲线救国，使用 Racket，并配置 SICP 兼容包。

这一章也可以叫做 Lisp 入门。用其他语言教程的话来说，这一章学习了基本语法，变量、函数的定义，条件语句等等.
** 程序设计的基本元素
*** 表达式
Lisp 解释器对输入表达式进行 *求值* 。

如果你键入了数字，那么很简单的，Lisp 解释器的反应是把它原封不动地返回。
这里的数字准确来说应该称作 /由数字组成的表达式/ 。
#+begin_src racket :lang sicp
  (1024)
#+end_src

#+RESULTS:
: 1024

可以用基本过程的表达形式(例如 =+= 或者 =*=)，将表示数的表达式组合起来，形成复合表达式，以表示求要把有关过程应用于这些数。
#+begin_src racket :lang sicp
  (+ 147 258)
#+end_src

#+RESULTS:
: 405

这样的表达式被称作 /组合式/ ，形式为一对括号括起一些表达式，形成一个表。表中最左的元素被称为 /运算符/ ，其他元素都被称为 /运算对象/ 。所谓 *求值* ，即是将运算符被定义的过程应用于运算对象.
表可以带有任意个实参.
#+begin_src racket :lang sicp
  (+ 147 258 369)
#+end_src

#+RESULTS:
: 774

同样也允许组合式 /嵌套/ 。
#+begin_src racket :lang sicp
  (+ (* 3 5) (- 10 6))
#+end_src

#+RESULTS:
: 19

一个比较复杂的嵌套表达式: 
: (+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))
也可以写成下面这种形式: 
#+begin_src racket :lang sicp
  ;; 为了美观
  (+ (* 3
        (+ (* 2 4)
           (+ 3 5)))
     (+ (- 10 7)
        6))
#+end_src

#+RESULTS:
: 57

即使对于非常复杂的表达式，解释器也总是按同样的基本循环运作。我们可以说，解释器运行在一个 /读入-求值-打印/ 循环中。
*** 命名和环境
/变量/ 是名字标识符， /值/ 是它所对应的对象。
在 Scheme 中，给事物命名通过 =define= 的方式完成。
#+begin_src racket :lang sicp
  (define size 2)

  (* 5 size)
#+end_src

#+RESULTS:
: 10

我们可以将值和符号相关联，而解释器必须有存储这种关联的能力。这种存储被称为 /环境/ 。
*** 组合式的求值
一个 Lisp 程序通常总是由一大批相对简单的过程组成的。

要求值一个表达式，就要做：
1。求值该组合式的各个子表达式。
2。将作为最左子表达式的过程应用于相应的实参。

我们可以看到，在性质上，这一求值过程是 /递归/ 的。
例如，对下列表达式求值：
#+begin_src racket :lang sicp
  (* (+ 2 (* 4 6)
        (+ 3 5 7)))
#+end_src

#+RESULTS:
: 41

#+begin_center
[[./img/tree_presentation.png]]

_树形表示方法_
#+end_center

如上图所示，我们可以采用一棵树的形式表示这一组合式的求值过程，其中的每个组合式用一个带分枝的节点表示由它发出的分支表示这一组合式的运算符和各个运算对象。可以设想，运算对象的值由终端节点开始，而后在越来越高的层次中组合起来。这种计算过程称为 /树形积累/ 。

为了判别组合式和基本表达式，我们有如下规定：
- 数的值就是它们所表示的值。
- 内部运算符的值就是能完成相应操作的机器指令序列。
- 其他名字的值就是在环境中关联与这一名字的那个对象。

一个例外是， =define= 并不适用于这套求值规则，这是一种 /特殊形式/ ，或称 /语法糖/ 。
*** 复合过程
通过 /过程定义/ ， 我们可以给 /复合过程/ 提供名字，而后就可以将这样的操作作为一个单元使用。
例如，“平方”在 Lisp 中可以表述为：
: (define (square x) (* x x))
过程定义的一般形式是：
: (define (<name> <formal parameters>) <body>)
在应用这一过程是，这一表达式中的形式参数将被与之对应的实际参数取代，并对该表达式求值。

#+begin_src racket :lang sicp
  (define (square x) (* x x))

  (square 21) ;; 441
  (square (+ 2 5)) ;; 49
  (square (square 3)) ;; 81

  ;; 定义其他过程
  (define (sum-of-squares x y)
    ;; 在过程中使用过程
    (+ (square x) (square y)))

  (sum-of-squares 3 4) ;; 25

  (define (f a)
    (sum-of-squares (+ a 1) (* a 2)))

  (f 5) ;; 136
#+end_src
*** 过程应用的代换模型
对于复合过程，过程应用的计算过程是：
将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。

假设我们有上一节中定义的过程，然后来求值下面的表达式：
: (f 5)
详细过程为：
#+begin_src racket :lang sicp
  (f 5) 
  (sum-of-squares (+ a 1) (* a 2)) ;; 提取 f 的体
  (sum-of-squares (+ 5 1) (* 5 2)) ;; 用实际参数 5 代换形式参数 a
  (+ (square 6) (square 10)) ;; 将 sum-of-squares 应用于 6 和 10
  (+ (* 6 6) (* 10 10)) ;; 使用 square 定义
  (+ 36 100) ;; 使用乘法定义
#+end_src
上面描述的这种计算过程称为过程应用的 /代换模型/ 。

事实上，这种模型只是为了帮助我们领会过程调用中的情况，实际的解释器在工作中会使用更加复杂的方式。我们将在以后讨论这一问题。
**** 应用序和正则序
执行求值的另一种可能方式：
#+begin_src racket :lang sicp
  ;; 先进行代换
  (f 5)
  (sum-of-squares (+ 5 1) (* 5 2))
  (+ (sqaure (+ 5 1))
     (square (* 5 2)))
  ;; 剩下基本运算符后进行求值
  (+ (* (+ 5 1)
        (+ 5 1))
     (* (* 5 2)
        (* 5 2)))
#+end_src
将所有的运算对象表达式进行代换，直至得到一个只包含基本运算符的表达式，然后再去执行求值。这种求值模型称为 /正则序求值/ ，我们刚才提到的，也是现在实际使用的求值方式被称作 /应用序求值/ 。
应用序求值首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。
*** 条件表达式和谓词
在 Lisp 里有一种针对 /分情况分析/ 的特殊形式，称为 =cond= 。
#+begin_src racket :lang sicp
  (define (abs x)
    (cond ((> x 0) x)
          ((= x 0) 0)
          ((< x 0) (-x))))
#+end_src
条件表达式的一般形式为：
#+begin_src racket :lang sicp
  (cond (<p1> <e1>)
        (<p2> <e2>)
        ...
        (<pn> <en>))
#+end_src
其中 =(<p> <e>)= 称作 /子句/ ， =<p>= 称作 /谓词/ 。
条件表达式的求值方式: 依次求值谓词，如果它的值是 =false= ，那么求取下一个谓词的值，直到发现某个谓词的值为真为止。如果无法找到值为真的谓词， =cond= 的值就没有定义。

一些其他的特殊形式：
#+begin_src racket :lang sicp
  ;; else 放在 cond 最后一个子句的位置，如果前面所有子句
  ;; 的值都为假，那么返回 else 子句中 <e> 的值
  (define (abs x)
    (cond ((< x 0) (-x))
          (else x)))

  ;; if 适用于只有两个情况的需要
  (define (abs x)
    (if (< x 0) ;; 谓词
        (-x)    ;; 为真时返回值
        x))     ;; 为假时返回值

  ;; 逻辑复合运算符
  (and <e1> <e2>..。<en>)
  (or <e1> <e2>..。<en>)
  (not <e>)

#+end_src
*** 实例: 使用牛顿法求平方根
函数(Function)与过程(Procedure)的差异：在数学里，人们通常关心的是说明性的描述(是什么)，而在计算机科学里，人们则通常关心行动性的描述(怎么做)。

最常用的平方根算法是牛顿的逐步逼近方法。
开始时，我们有被开方数的值和一个猜测值，如果猜测值已经足够好了，那么结束; 否则重复上述计算过程去改进猜测值。让我们设法用过程的语言来描述这一计算过程：
#+begin_src racket :lang sicp
  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                   x)))
#+end_src
改进猜测的方式就是求出它与被开方数除以上一个猜测的平均值：
#+begin_src racket :lang sicp
  (define (improve guess x)
    (average guess (/ x guess)))

  (define (average x y)
    (/ (+ x y) 2))
#+end_src
我们还必须说明什么叫做"足够好"。在这里我们简单地使用差小于误差这一方法：
#+begin_src racket :lang sicp
  (define (good-enough? guess x)
    (< (abs (- (square guess) x)) 0.001))
#+end_src
最后我们以初始猜测值为 =1= 开始：
#+begin_src racket :lang sicp
  (define (sqrt x)
    (sqrt-iter 1.0 x))
#+end_src
*** 过程作为黑箱抽象
可以看到，对于平方根的计算问题可以自然的分解为若干子问题。
#+begin_center
[[./img/procedural_decomposition_of_the_sqrt_program.png]]

_sqrt 程序的过程分解_
#+end_center
分解中的每一个过程都完成了一件可以清楚标明的工作，这使它们可以被用做定义其他过程的模块。
当我们定义 =good-enough?= 时，就无须关心 =square= 的具体实现，只需将它看作一个“黑箱”，只需注意它能够计算出平方值的事实。因此，如果只看 =good-enough?= 过程，那么与其说 =square= 是一个过程，不如说它是“平方值计算”过程的抽象，即所谓的 /过程抽象/ 。
也就是说，如果我们只考虑参数和返回值，下面这两个过程是等价的：
#+begin_src racket :lang sicp
  (define (square x) (* x x))

  (define (square x)
    (exp (double (log x))))
  (define (double x) (+ x x))
#+end_src
**** TODO 局部名

**** 内部定义和块结构
我们现在有了计算平方根的程序，其由几个相互分离的过程组成。
问题是，在这些过程里，只有 =sqrt= 对用户是重要的，其他的过程并不重要，还会干扰他们的命名：再也不能定义一个叫做 =good-enough?= 的过程了。于是，我们希望将这个种子过程局部化，将其隐藏在 =sqrt= 中。为了使这一方式成为可能，我们要允许一个过程里带有一些内部定义，使他们是局部于这一过程的：
#+begin_src racket :lang sicp
  (define (sqrt x)
    (define (good-enough? guess x)
      (< (abs (- (square guess) x)) 0.001))
    (define (improve guess x)
      (average guess (/ x guess)))
    (define (sqrt-iter guess x)
      (if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
    (sqrt-iter 1.0 x))
#+end_src
这种嵌套的定义称为 /块结构/ 。
** 过程及其产生的计算
*** 线性的递归和迭代
*** 树形递归
*** 增长的阶
*** 求幂
*** 最大公约数
*** 实例: 素数检测
** 用高阶函数做抽象
*** 过程作为参数
*** 用 lambda 构造过程
*** 过程作为一般性的方法
*** 过程作为返回值
* Chapter 2. 构造数据抽象
** 数据抽象导引
*** 实例: 有理数的算数运算
*** 抽象屏障
*** 数据意味着什么
*** 扩展练习: 区间算数
** 层次性数据和闭包性质
*** 序列的表示
*** 层次性结构
*** 序列作为一种约定的界面
*** 实例: 一个图形语言
** 符号数据
*** 引号
*** 实例: 符号求导
*** 实例: 集合的表示
*** 实例: Huffman 编码树
** 抽象数据的多重表示
*** 复数的表示
*** 带标志数据
*** 数据导向的程序设计和可加性
** 带有通用型操作的系统
*** 通用型算术运算
*** 不同类型数据的组合
*** 实例: 符号代数
* Chapter 3. 模块化、对象和状态
** 赋值和局部状态
*** 局部状态变量
*** 引进赋值带来的利益
*** 引进赋值的代价
** 求值的环境模型
*** 求值规则
*** 简单过程的应用
*** 将框架看作局部状态的展台
*** 内部定义
** 用变动数据做模拟
*** 变动的表结构
*** 队列的表示
*** 表格的表示
*** 数字电路的模拟器
*** 约束的传播
** 并发: 时间是一个本质问题
*** 并发系统中时间的性质
*** 控制并发的机制
** 流
*** 流作为延时的表
*** 无穷流
*** 流计算模式的运用
*** 流和延时求值
*** 函数式程序的模块化和对象的模块化
* Chapter 4. 元语言抽象
** 元循环求值器
*** 求值器的内核
*** 表达式的表示
*** 求值器数据结构
*** 作为程序运行求值器
*** 将数据作为程序
*** 内部定义
*** 讲语法分析与执行分离
** Scheme 的变形——惰性求值
*** 正则序和应用序
*** 一个采用惰性求值的解释器
*** 将流作为惰性的表
** Scheme 的变形——非确定性计算
*** amb 和搜索
*** 非确定性程序的实例
*** 实现 amb 求值器
** 逻辑程序设计
*** 演绎信息检索
*** 查询系统如何工作
*** 逻辑程序设计是数理逻辑吗
*** 查询系统的实现
* Chapter 5. 寄存器机器里的计算
** 寄存器机器的设计
*** 一种描述寄存器机器的语言
*** 机器设计的抽象
*** 子程序
*** 采用堆栈实现递归
*** 指令总结
** 一个寄存器机器模拟器
*** 机器模型
*** 汇编程序
*** 为指令生成执行过程
*** 监视机器执行
** 存储分配和废料收集
*** 将存储看作向量
*** 维持一种无穷存储的假象
** 显式控制的求值器
*** 显示控制求值器的内核
*** 序列的求值和尾递归
*** 条件、赋值和定义
*** 求值器的运行
** 编译
*** 编译器的结构
*** 表达式的编译
*** 组合式的编译
*** 指令序列的组合
*** 编译代码的实例
*** 词法地址
*** 编译代码和求值器的互连

